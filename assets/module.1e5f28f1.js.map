{"version":3,"file":"module.1e5f28f1.js","sources":["../../node_modules/@react-stately/utils/dist/module.js"],"sourcesContent":["import {useState as $6imuh$useState, useRef as $6imuh$useRef, useCallback as $6imuh$useCallback} from \"react\";\n\n\nfunction $458b0a5536c1a7cf$export$40bfa8c7b0832715(value1, defaultValue, onChange) {\n    let [stateValue, setStateValue] = $6imuh$useState(value1 || defaultValue);\n    let ref = $6imuh$useRef(value1 !== undefined);\n    let wasControlled = ref.current;\n    let isControlled = value1 !== undefined;\n    // Internal state reference for useCallback\n    let stateRef = $6imuh$useRef(stateValue);\n    if (wasControlled !== isControlled) console.warn(`WARN: A component changed from ${wasControlled ? 'controlled' : 'uncontrolled'} to ${isControlled ? 'controlled' : 'uncontrolled'}.`);\n    ref.current = isControlled;\n    let setValue = $6imuh$useCallback((value2, ...args)=>{\n        let onChangeCaller = (value, ...onChangeArgs)=>{\n            if (onChange) {\n                if (!Object.is(stateRef.current, value)) onChange(value, ...onChangeArgs);\n            }\n            if (!isControlled) stateRef.current = value;\n        };\n        if (typeof value2 === 'function') {\n            console.warn('We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320');\n            // this supports functional updates https://reactjs.org/docs/hooks-reference.html#functional-updates\n            // when someone using useControlledState calls setControlledState(myFunc)\n            // this will call our useState setState with a function as well which invokes myFunc and calls onChange with the value from myFunc\n            // if we're in an uncontrolled state, then we also return the value of myFunc which to setState looks as though it was just called with myFunc from the beginning\n            // otherwise we just return the controlled value, which won't cause a rerender because React knows to bail out when the value is the same\n            let updateFunction = (oldValue, ...functionArgs)=>{\n                let interceptedValue = value2(isControlled ? stateRef.current : oldValue, ...functionArgs);\n                onChangeCaller(interceptedValue, ...args);\n                if (!isControlled) return interceptedValue;\n                return oldValue;\n            };\n            setStateValue(updateFunction);\n        } else {\n            if (!isControlled) setStateValue(value2);\n            onChangeCaller(value2, ...args);\n        }\n    }, [\n        isControlled,\n        onChange\n    ]);\n    // If a controlled component's value prop changes, we need to update stateRef\n    if (isControlled) stateRef.current = value1;\n    else value1 = stateValue;\n    return [\n        value1,\n        setValue\n    ];\n}\n\n\nfunction $9446cca9a3875146$export$7d15b64cf5a3a4c4(value, min = -Infinity, max = Infinity) {\n    let newValue = Math.min(Math.max(value, min), max);\n    return newValue;\n}\nfunction $9446cca9a3875146$export$cb6e0bb50bc19463(value, min, max, step) {\n    let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n    let snappedValue = Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder;\n    if (!isNaN(min)) {\n        if (snappedValue < min) snappedValue = min;\n        else if (!isNaN(max) && snappedValue > max) snappedValue = min + Math.floor((max - min) / step) * step;\n    } else if (!isNaN(max) && snappedValue > max) snappedValue = Math.floor(max / step) * step;\n    // correct floating point behavior by rounding to step precision\n    let string = step.toString();\n    let index = string.indexOf('.');\n    let precision = index >= 0 ? string.length - index : 0;\n    if (precision > 0) {\n        let pow = Math.pow(10, precision);\n        snappedValue = Math.round(snappedValue * pow) / pow;\n    }\n    return snappedValue;\n}\nfunction $9446cca9a3875146$export$b6268554fba451f(value, digits, base = 10) {\n    const pow = Math.pow(base, digits);\n    return Math.round(value * pow) / pow;\n}\n\n\n\n\nexport {$458b0a5536c1a7cf$export$40bfa8c7b0832715 as useControlledState, $9446cca9a3875146$export$7d15b64cf5a3a4c4 as clamp, $9446cca9a3875146$export$cb6e0bb50bc19463 as snapValueToStep, $9446cca9a3875146$export$b6268554fba451f as toFixedNumber};\n//# sourceMappingURL=module.js.map\n"],"names":["$458b0a5536c1a7cf$export$40bfa8c7b0832715","value1","defaultValue","onChange","stateValue","setStateValue","$6imuh$useState","ref","$6imuh$useRef","wasControlled","isControlled","stateRef","setValue","$6imuh$useCallback","value2","args","onChangeCaller","value","onChangeArgs","oldValue","functionArgs","interceptedValue","$9446cca9a3875146$export$7d15b64cf5a3a4c4","min","max"],"mappings":"8CAGA,SAASA,EAA0CC,EAAQC,EAAcC,EAAU,CAC/E,GAAI,CAACC,EAAYC,CAAa,EAAIC,EAAAA,QAAAA,SAAgBL,GAAUC,CAAY,EACpEK,EAAMC,EAAAA,QAAAA,OAAcP,IAAW,MAAS,EACxCQ,EAAgBF,EAAI,QACpBG,EAAeT,IAAW,OAE1BU,EAAWH,iBAAcJ,CAAU,EACnCK,IAAkBC,GAAc,QAAQ,KAAK,kCAAkCD,EAAgB,aAAe,qBAAqBC,EAAe,aAAe,iBAAiB,EACtLH,EAAI,QAAUG,EACd,IAAIE,EAAWC,EAAkB,QAAA,YAAC,CAACC,KAAWC,IAAO,CACjD,IAAIC,EAAiB,CAACC,KAAUC,IAAe,CACvCf,IACK,OAAO,GAAGQ,EAAS,QAASM,CAAK,GAAGd,EAASc,EAAO,GAAGC,CAAY,GAEvER,IAAcC,EAAS,QAAUM,EAClD,EACY,OAAOH,GAAW,YAClB,QAAQ,KAAK,2HAA2H,EAYxIT,EANqB,CAACc,KAAaC,IAAe,CAC9C,IAAIC,EAAmBP,EAAOJ,EAAeC,EAAS,QAAUQ,EAAU,GAAGC,CAAY,EAEzF,OADAJ,EAAeK,EAAkB,GAAGN,CAAI,EACnCL,EACES,EADmBE,CAE1C,CACwC,IAEvBX,GAAcL,EAAcS,CAAM,EACvCE,EAAeF,EAAQ,GAAGC,CAAI,EAE1C,EAAO,CACCL,EACAP,CACR,CAAK,EAED,OAAIO,EAAcC,EAAS,QAAUV,EAChCA,EAASG,EACP,CACHH,EACAW,CACR,CACA,CAGA,SAASU,EAA0CL,EAAOM,EAAM,KAAWC,EAAM,IAAU,CAEvF,OADe,KAAK,IAAI,KAAK,IAAIP,EAAOM,CAAG,EAAGC,CAAG,CAErD"}