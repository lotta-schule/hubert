{"version":3,"file":"module.0e81a828.js","sources":["../../node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs","../../node_modules/framer-motion/dist/es/utils/use-force-update.mjs","../../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs","../../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs","../../node_modules/@react-aria/focus/dist/module.js","../../node_modules/@react-stately/overlays/dist/module.js"],"sourcesContent":["import { useRef } from 'react';\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-effect.mjs';\n\nfunction useIsMounted() {\n    var isMounted = useRef(false);\n    useIsomorphicLayoutEffect(function () {\n        isMounted.current = true;\n        return function () {\n            isMounted.current = false;\n        };\n    }, []);\n    return isMounted;\n}\n\nexport { useIsMounted };\n","import { __read } from 'tslib';\nimport sync from 'framesync';\nimport { useState, useCallback } from 'react';\nimport { useIsMounted } from './use-is-mounted.mjs';\n\nfunction useForceUpdate() {\n    var isMounted = useIsMounted();\n    var _a = __read(useState(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n    var forceRender = useCallback(function () {\n        isMounted.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [forcedRenderCount]);\n    /**\n     * Defer this to the end of the next animation frame in case there are multiple\n     * synchronous calls.\n     */\n    var deferredForceRender = useCallback(function () { return sync.postRender(forceRender); }, [forceRender]);\n    return [deferredForceRender, forcedRenderCount];\n}\n\nexport { useForceUpdate };\n","import { __values } from 'tslib';\nimport * as React from 'react';\nimport { useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useId } from '../../utils/use-id.mjs';\n\nvar PresenceChild = function (_a) {\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;\n    var presenceChildren = useConstant(newChildrenMap);\n    var id = useId();\n    var context = useMemo(function () { return ({\n        id: id,\n        initial: initial,\n        isPresent: isPresent,\n        custom: custom,\n        onExitComplete: function (childId) {\n            var e_1, _a;\n            presenceChildren.set(childId, true);\n            try {\n                for (var _b = __values(presenceChildren.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var isComplete = _c.value;\n                    if (!isComplete)\n                        return; // can stop searching when any is incomplete\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete();\n        },\n        register: function (childId) {\n            presenceChildren.set(childId, false);\n            return function () { return presenceChildren.delete(childId); };\n        },\n    }); }, \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout ? undefined : [isPresent]);\n    useMemo(function () {\n        presenceChildren.forEach(function (_, key) { return presenceChildren.set(key, false); });\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(function () {\n        !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n    }, [isPresent]);\n    return (React.createElement(PresenceContext.Provider, { value: context }, children));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n","import { __read, __spreadArray } from 'tslib';\nimport * as React from 'react';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { env } from '../../utils/process.mjs';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\n\nvar getChildKey = function (child) { return child.key || \"\"; };\nfunction updateChildLookup(children, allChildren) {\n    children.forEach(function (child) {\n        var key = getChildKey(child);\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, function (child) {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var _d = __read(useForceUpdate(), 1), forceRender = _d[0];\n    var forceRenderLayoutGroup = useContext(LayoutGroupContext).forceRender;\n    if (forceRenderLayoutGroup)\n        forceRender = forceRenderLayoutGroup;\n    var isMounted = useIsMounted();\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    var childrenToRender = filteredChildren;\n    var exiting = new Set();\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = useRef(childrenToRender);\n    // A lookup table to quickly reference components by key\n    var allChildren = useRef(new Map()).current;\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    var isInitialRender = useRef(true);\n    useIsomorphicLayoutEffect(function () {\n        isInitialRender.current = false;\n        updateChildLookup(filteredChildren, allChildren);\n        presentChildren.current = childrenToRender;\n    });\n    useUnmountEffect(function () {\n        isInitialRender.current = true;\n        allChildren.clear();\n        exiting.clear();\n    });\n    if (isInitialRender.current) {\n        return (React.createElement(React.Fragment, null, childrenToRender.map(function (child) { return (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    childrenToRender = __spreadArray([], __read(childrenToRender), false);\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for (var i = 0; i < numPresent; i++) {\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function (key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        var child = allChildren.get(key);\n        if (!child)\n            return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function () {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                if (isMounted.current === false)\n                    return;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function (child) {\n        var key = child.key;\n        return exiting.has(key) ? (child) : (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    if (env !== \"production\" &&\n        exitBeforeEnter &&\n        childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return (React.createElement(React.Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map(function (child) { return cloneElement(child); })));\n};\n\nexport { AnimatePresence };\n","import $6nfFC$react, {useRef as $6nfFC$useRef, useContext as $6nfFC$useContext, useEffect as $6nfFC$useEffect, useState as $6nfFC$useState, useCallback as $6nfFC$useCallback} from \"react\";\nimport {useLayoutEffect as $6nfFC$useLayoutEffect, runAfterTransition as $6nfFC$runAfterTransition, focusWithoutScrolling as $6nfFC$focusWithoutScrolling, mergeProps as $6nfFC$mergeProps, useSyncRef as $6nfFC$useSyncRef} from \"@react-aria/utils\";\nimport {getInteractionModality as $6nfFC$getInteractionModality, isFocusVisible as $6nfFC$isFocusVisible, useFocusVisibleListener as $6nfFC$useFocusVisibleListener, useFocus as $6nfFC$useFocus, useFocusWithin as $6nfFC$useFocusWithin, useKeyboard as $6nfFC$useKeyboard} from \"@react-aria/interactions\";\nimport $6nfFC$clsx from \"clsx\";\n\n\n\nfunction $6a99195332edec8b$export$80f3e147d781571c(element) {\n    // If the user is interacting with a virtual cursor, e.g. screen reader, then\n    // wait until after any animated transitions that are currently occurring on\n    // the page before shifting focus. This avoids issues with VoiceOver on iOS\n    // causing the page to scroll when moving focus if the element is transitioning\n    // from off the screen.\n    if ($6nfFC$getInteractionModality() === 'virtual') {\n        let lastFocusedElement = document.activeElement;\n        $6nfFC$runAfterTransition(()=>{\n            // If focus did not move and the element is still in the document, focus it.\n            if (document.activeElement === lastFocusedElement && document.contains(element)) $6nfFC$focusWithoutScrolling(element);\n        });\n    } else $6nfFC$focusWithoutScrolling(element);\n}\n\n\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $645f2e67b85a24c9$var$isStyleVisible(element) {\n    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;\n    let { display: display , visibility: visibility  } = element.style;\n    let isVisible = display !== 'none' && visibility !== 'hidden' && visibility !== 'collapse';\n    if (isVisible) {\n        const { getComputedStyle: getComputedStyle  } = element.ownerDocument.defaultView;\n        let { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);\n        isVisible = computedDisplay !== 'none' && computedVisibility !== 'hidden' && computedVisibility !== 'collapse';\n    }\n    return isVisible;\n}\nfunction $645f2e67b85a24c9$var$isAttributeVisible(element, childElement) {\n    return !element.hasAttribute('hidden') && (element.nodeName === 'DETAILS' && childElement && childElement.nodeName !== 'SUMMARY' ? element.hasAttribute('open') : true);\n}\nfunction $645f2e67b85a24c9$export$e989c0fffaa6b27a(element, childElement) {\n    return element.nodeName !== '#comment' && $645f2e67b85a24c9$var$isStyleVisible(element) && $645f2e67b85a24c9$var$isAttributeVisible(element, childElement) && (!element.parentElement || $645f2e67b85a24c9$export$e989c0fffaa6b27a(element.parentElement, element));\n}\n\n\n\n\nconst $9bf71ea28793e738$var$FocusContext = /*#__PURE__*/ $6nfFC$react.createContext(null);\nlet $9bf71ea28793e738$var$activeScope = null;\nlet $9bf71ea28793e738$var$scopes = new Map();\nfunction $9bf71ea28793e738$export$20e40289641fbbb6(props) {\n    let { children: children , contain: contain , restoreFocus: restoreFocus , autoFocus: autoFocus  } = props;\n    let startRef = $6nfFC$useRef();\n    let endRef = $6nfFC$useRef();\n    let scopeRef = $6nfFC$useRef([]);\n    let ctx = $6nfFC$useContext($9bf71ea28793e738$var$FocusContext);\n    let parentScope = ctx === null || ctx === void 0 ? void 0 : ctx.scopeRef;\n    $6nfFC$useLayoutEffect(()=>{\n        // Find all rendered nodes between the sentinels and add them to the scope.\n        let node = startRef.current.nextSibling;\n        let nodes = [];\n        while(node && node !== endRef.current){\n            nodes.push(node);\n            node = node.nextSibling;\n        }\n        scopeRef.current = nodes;\n    }, [\n        children,\n        parentScope\n    ]);\n    $6nfFC$useLayoutEffect(()=>{\n        $9bf71ea28793e738$var$scopes.set(scopeRef, parentScope);\n        return ()=>{\n            // Restore the active scope on unmount if this scope or a descendant scope is active.\n            // Parent effect cleanups run before children, so we need to check if the\n            // parent scope actually still exists before restoring the active scope to it.\n            if ((scopeRef === $9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope(scopeRef, $9bf71ea28793e738$var$activeScope)) && (!parentScope || $9bf71ea28793e738$var$scopes.has(parentScope))) $9bf71ea28793e738$var$activeScope = parentScope;\n            $9bf71ea28793e738$var$scopes.delete(scopeRef);\n        };\n    }, [\n        scopeRef,\n        parentScope\n    ]);\n    $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain);\n    $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain);\n    $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus);\n    let focusManager = $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef);\n    return(/*#__PURE__*/ $6nfFC$react.createElement($9bf71ea28793e738$var$FocusContext.Provider, {\n        value: {\n            scopeRef: scopeRef,\n            focusManager: focusManager\n        }\n    }, /*#__PURE__*/ $6nfFC$react.createElement(\"span\", {\n        \"data-focus-scope-start\": true,\n        hidden: true,\n        ref: startRef\n    }), children, /*#__PURE__*/ $6nfFC$react.createElement(\"span\", {\n        \"data-focus-scope-end\": true,\n        hidden: true,\n        ref: endRef\n    })));\n}\nfunction $9bf71ea28793e738$export$10c5169755ce7bd7() {\n    var ref;\n    return (ref = $6nfFC$useContext($9bf71ea28793e738$var$FocusContext)) === null || ref === void 0 ? void 0 : ref.focusManager;\n}\nfunction $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef) {\n    return {\n        focusNext (opts = {\n        }) {\n            let scope = scopeRef.current;\n            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;\n            let node = from || document.activeElement;\n            let sentinel = scope[0].previousElementSibling;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa($9bf71ea28793e738$var$getScopeRoot(scope), {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node, scope) ? node : sentinel;\n            let nextNode = walker.nextNode();\n            if (!nextNode && wrap) {\n                walker.currentNode = sentinel;\n                nextNode = walker.nextNode();\n            }\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusPrevious (opts = {\n        }) {\n            let scope = scopeRef.current;\n            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;\n            let node = from || document.activeElement;\n            let sentinel = scope[scope.length - 1].nextElementSibling;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa($9bf71ea28793e738$var$getScopeRoot(scope), {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node, scope) ? node : sentinel;\n            let previousNode = walker.previousNode();\n            if (!previousNode && wrap) {\n                walker.currentNode = sentinel;\n                previousNode = walker.previousNode();\n            }\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode;\n        },\n        focusFirst (opts = {\n        }) {\n            let scope = scopeRef.current;\n            let { tabbable: tabbable , accept: accept  } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa($9bf71ea28793e738$var$getScopeRoot(scope), {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = scope[0].previousElementSibling;\n            let nextNode = walker.nextNode();\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusLast (opts = {\n        }) {\n            let scope = scopeRef.current;\n            let { tabbable: tabbable , accept: accept  } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa($9bf71ea28793e738$var$getScopeRoot(scope), {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = scope[scope.length - 1].nextElementSibling;\n            let previousNode = walker.previousNode();\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode;\n        }\n    };\n}\nconst $9bf71ea28793e738$var$focusableElements = [\n    'input:not([disabled]):not([type=hidden])',\n    'select:not([disabled])',\n    'textarea:not([disabled])',\n    'button:not([disabled])',\n    'a[href]',\n    'area[href]',\n    'summary',\n    'iframe',\n    'object',\n    'embed',\n    'audio[controls]',\n    'video[controls]',\n    '[contenteditable]'\n];\nconst $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(':not([hidden]),') + ',[tabindex]:not([disabled]):not([hidden])';\n$9bf71ea28793e738$var$focusableElements.push('[tabindex]:not([tabindex=\"-1\"]):not([disabled])');\nconst $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(':not([hidden]):not([tabindex=\"-1\"]),');\nfunction $9bf71ea28793e738$var$getScopeRoot(scope) {\n    return scope[0].parentElement;\n}\nfunction $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {\n    let focusedNode = $6nfFC$useRef();\n    let raf = $6nfFC$useRef(null);\n    $6nfFC$useLayoutEffect(()=>{\n        let scope1 = scopeRef.current;\n        if (!contain) {\n            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment\n            if (raf.current) {\n                cancelAnimationFrame(raf.current);\n                raf.current = null;\n            }\n            return;\n        }\n        // Handle the Tab key to contain focus within the scope\n        let onKeyDown = (e)=>{\n            if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || scopeRef !== $9bf71ea28793e738$var$activeScope) return;\n            let focusedElement = document.activeElement;\n            let scope = scopeRef.current;\n            if (!$9bf71ea28793e738$var$isElementInScope(focusedElement, scope)) return;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa($9bf71ea28793e738$var$getScopeRoot(scope), {\n                tabbable: true\n            }, scope);\n            walker.currentNode = focusedElement;\n            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            if (!nextElement) {\n                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;\n                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            }\n            e.preventDefault();\n            if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);\n        };\n        let onFocus = (e)=>{\n            // If focusing an element in a child scope of the currently active scope, the child becomes active.\n            // Moving out of the active scope to an ancestor is not allowed.\n            if (!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) {\n                $9bf71ea28793e738$var$activeScope = scopeRef;\n                focusedNode.current = e.target;\n            } else if (scopeRef === $9bf71ea28793e738$var$activeScope && !$9bf71ea28793e738$var$isElementInChildScope(e.target, scopeRef)) {\n                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),\n                // restore focus to the previously focused node or the first tabbable element in the active scope.\n                if (focusedNode.current) focusedNode.current.focus();\n                else if ($9bf71ea28793e738$var$activeScope) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);\n            } else if (scopeRef === $9bf71ea28793e738$var$activeScope) focusedNode.current = e.target;\n        };\n        let onBlur = (e)=>{\n            // Firefox doesn't shift focus back to the Dialog properly without this\n            raf.current = requestAnimationFrame(()=>{\n                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe\n                if (scopeRef === $9bf71ea28793e738$var$activeScope && !$9bf71ea28793e738$var$isElementInChildScope(document.activeElement, scopeRef)) {\n                    $9bf71ea28793e738$var$activeScope = scopeRef;\n                    focusedNode.current = e.target;\n                    focusedNode.current.focus();\n                }\n            });\n        };\n        document.addEventListener('keydown', onKeyDown, false);\n        document.addEventListener('focusin', onFocus, false);\n        scope1.forEach((element)=>element.addEventListener('focusin', onFocus, false)\n        );\n        scope1.forEach((element)=>element.addEventListener('focusout', onBlur, false)\n        );\n        return ()=>{\n            document.removeEventListener('keydown', onKeyDown, false);\n            document.removeEventListener('focusin', onFocus, false);\n            scope1.forEach((element)=>element.removeEventListener('focusin', onFocus, false)\n            );\n            scope1.forEach((element)=>element.removeEventListener('focusout', onBlur, false)\n            );\n        };\n    }, [\n        scopeRef,\n        contain\n    ]);\n    // eslint-disable-next-line arrow-body-style\n    $6nfFC$useEffect(()=>{\n        return ()=>{\n            if (raf.current) cancelAnimationFrame(raf.current);\n        };\n    }, [\n        raf\n    ]);\n}\nfunction $9bf71ea28793e738$var$isElementInAnyScope(element) {\n    for (let scope of $9bf71ea28793e738$var$scopes.keys()){\n        if ($9bf71ea28793e738$var$isElementInScope(element, scope.current)) return true;\n    }\n    return false;\n}\nfunction $9bf71ea28793e738$var$isElementInScope(element, scope) {\n    return scope.some((node)=>node.contains(element)\n    );\n}\nfunction $9bf71ea28793e738$var$isElementInChildScope(element, scope) {\n    // node.contains in isElementInScope covers child scopes that are also DOM children,\n    // but does not cover child scopes in portals.\n    for (let s of $9bf71ea28793e738$var$scopes.keys()){\n        if ((s === scope || $9bf71ea28793e738$var$isAncestorScope(scope, s)) && $9bf71ea28793e738$var$isElementInScope(element, s.current)) return true;\n    }\n    return false;\n}\nfunction $9bf71ea28793e738$var$isAncestorScope(ancestor, scope) {\n    let parent = $9bf71ea28793e738$var$scopes.get(scope);\n    if (!parent) return false;\n    if (parent === ancestor) return true;\n    return $9bf71ea28793e738$var$isAncestorScope(ancestor, parent);\n}\nfunction $9bf71ea28793e738$var$focusElement(element, scroll = false) {\n    if (element != null && !scroll) try {\n        $6a99195332edec8b$export$80f3e147d781571c(element);\n    } catch (err) {\n    // ignore\n    }\n    else if (element != null) try {\n        element.focus();\n    } catch (err1) {\n    // ignore\n    }\n}\nfunction $9bf71ea28793e738$var$focusFirstInScope(scope) {\n    let sentinel = scope[0].previousElementSibling;\n    let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa($9bf71ea28793e738$var$getScopeRoot(scope), {\n        tabbable: true\n    }, scope);\n    walker.currentNode = sentinel;\n    $9bf71ea28793e738$var$focusElement(walker.nextNode());\n}\nfunction $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus) {\n    const autoFocusRef = $6nfFC$react.useRef(autoFocus);\n    $6nfFC$useEffect(()=>{\n        if (autoFocusRef.current) {\n            $9bf71ea28793e738$var$activeScope = scopeRef;\n            if (!$9bf71ea28793e738$var$isElementInScope(document.activeElement, $9bf71ea28793e738$var$activeScope.current)) $9bf71ea28793e738$var$focusFirstInScope(scopeRef.current);\n        }\n        autoFocusRef.current = false;\n    }, []);\n}\nfunction $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain) {\n    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.\n    const nodeToRestoreRef = $6nfFC$useRef(typeof document !== 'undefined' ? document.activeElement : null);\n    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.\n    $6nfFC$useLayoutEffect(()=>{\n        let nodeToRestore = nodeToRestoreRef.current;\n        if (!restoreFocus) return;\n        // Handle the Tab key so that tabbing out of the scope goes to the next element\n        // after the node that had focus when the scope mounted. This is important when\n        // using portals for overlays, so that focus goes to the expected element when\n        // tabbing out of the overlay.\n        let onKeyDown = (e)=>{\n            if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) return;\n            let focusedElement = document.activeElement;\n            if (!$9bf71ea28793e738$var$isElementInScope(focusedElement, scopeRef.current)) return;\n            // Create a DOM tree walker that matches all tabbable elements\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(document.body, {\n                tabbable: true\n            });\n            // Find the next tabbable element after the currently focused element\n            walker.currentNode = focusedElement;\n            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) nodeToRestore = null;\n            // If there is no next element, or it is outside the current scope, move focus to the\n            // next element after the node to restore to instead.\n            if ((!nextElement || !$9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {\n                walker.currentNode = nodeToRestore;\n                // Skip over elements within the scope, in case the scope immediately follows the node to restore.\n                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n                while ($9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current))\n                e.preventDefault();\n                e.stopPropagation();\n                if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);\n                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)\n                // then move focus to the body.\n                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)\n                if (!$9bf71ea28793e738$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();\n                else $9bf71ea28793e738$var$focusElement(nodeToRestore, true);\n            }\n        };\n        if (!contain) document.addEventListener('keydown', onKeyDown, true);\n        return ()=>{\n            if (!contain) document.removeEventListener('keydown', onKeyDown, true);\n            if (restoreFocus && nodeToRestore && $9bf71ea28793e738$var$isElementInScope(document.activeElement, scopeRef.current)) requestAnimationFrame(()=>{\n                // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere\n                if (document.body.contains(nodeToRestore) && document.activeElement === document.body) $9bf71ea28793e738$var$focusElement(nodeToRestore);\n            });\n        };\n    }, [\n        scopeRef,\n        restoreFocus,\n        contain\n    ]);\n}\nfunction $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, opts, scope) {\n    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR : $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR;\n    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n        acceptNode (node) {\n            var ref;\n            // Skip nodes inside the starting node.\n            if (opts === null || opts === void 0 ? void 0 : (ref = opts.from) === null || ref === void 0 ? void 0 : ref.contains(node)) return NodeFilter.FILTER_REJECT;\n            if (node.matches(selector) && $645f2e67b85a24c9$export$e989c0fffaa6b27a(node) && (!scope || $9bf71ea28793e738$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;\n            return NodeFilter.FILTER_SKIP;\n        }\n    });\n    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;\n    return walker;\n}\nfunction $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {\n}) {\n    return {\n        focusNext (opts = {\n        }) {\n            let root = ref.current;\n            if (!root) return;\n            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;\n            let node = from || document.activeElement;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            if (root.contains(node)) walker.currentNode = node;\n            let nextNode = walker.nextNode();\n            if (!nextNode && wrap) {\n                walker.currentNode = root;\n                nextNode = walker.nextNode();\n            }\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusPrevious (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return;\n            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;\n            let node = from || document.activeElement;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            if (root.contains(node)) walker.currentNode = node;\n            else {\n                let next = $9bf71ea28793e738$var$last(walker);\n                if (next) $9bf71ea28793e738$var$focusElement(next, true);\n                return next;\n            }\n            let previousNode = walker.previousNode();\n            if (!previousNode && wrap) {\n                walker.currentNode = root;\n                previousNode = $9bf71ea28793e738$var$last(walker);\n            }\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode;\n        },\n        focusFirst (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return;\n            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            let nextNode = walker.nextNode();\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusLast (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return;\n            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            let next = $9bf71ea28793e738$var$last(walker);\n            if (next) $9bf71ea28793e738$var$focusElement(next, true);\n            return next;\n        }\n    };\n}\nfunction $9bf71ea28793e738$var$last(walker) {\n    let next;\n    let last;\n    do {\n        last = walker.lastChild();\n        if (last) next = last;\n    }while (last)\n    return next;\n}\n\n\n\n\n\n\n\n\nfunction $f7dceffc5ad7768b$export$4e328f61c538687f(props = {\n}) {\n    let { autoFocus: autoFocus = false , isTextInput: isTextInput , within: within  } = props;\n    let state = $6nfFC$useRef({\n        isFocused: false,\n        isFocusVisible: autoFocus || $6nfFC$isFocusVisible()\n    });\n    let [isFocused1, setFocused] = $6nfFC$useState(false);\n    let [isFocusVisibleState, setFocusVisible] = $6nfFC$useState(()=>state.current.isFocused && state.current.isFocusVisible\n    );\n    let updateState = $6nfFC$useCallback(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible)\n    , []);\n    let onFocusChange = $6nfFC$useCallback((isFocused)=>{\n        state.current.isFocused = isFocused;\n        setFocused(isFocused);\n        updateState();\n    }, [\n        updateState\n    ]);\n    $6nfFC$useFocusVisibleListener((isFocusVisible)=>{\n        state.current.isFocusVisible = isFocusVisible;\n        updateState();\n    }, [], {\n        isTextInput: isTextInput\n    });\n    let { focusProps: focusProps  } = $6nfFC$useFocus({\n        isDisabled: within,\n        onFocusChange: onFocusChange\n    });\n    let { focusWithinProps: focusWithinProps  } = $6nfFC$useFocusWithin({\n        isDisabled: !within,\n        onFocusWithinChange: onFocusChange\n    });\n    return {\n        isFocused: isFocused1,\n        isFocusVisible: state.current.isFocused && isFocusVisibleState,\n        focusProps: within ? focusWithinProps : focusProps\n    };\n}\n\n\nfunction $907718708eab68af$export$1a38b4ad7f578e1d(props) {\n    let { children: children , focusClass: focusClass , focusRingClass: focusRingClass  } = props;\n    let { isFocused: isFocused , isFocusVisible: isFocusVisible , focusProps: focusProps  } = $f7dceffc5ad7768b$export$4e328f61c538687f(props);\n    let child = $6nfFC$react.Children.only(children);\n    return(/*#__PURE__*/ $6nfFC$react.cloneElement(child, $6nfFC$mergeProps(child.props, {\n        ...focusProps,\n        className: $6nfFC$clsx({\n            [focusClass || '']: isFocused,\n            [focusRingClass || '']: isFocusVisible\n        })\n    })));\n}\n\n\n\n\n\n\nlet $e6afbd83fe6ebbd2$var$FocusableContext = /*#__PURE__*/ $6nfFC$react.createContext(null);\nfunction $e6afbd83fe6ebbd2$var$useFocusableContext(ref) {\n    let context = $6nfFC$useContext($e6afbd83fe6ebbd2$var$FocusableContext) || {\n    };\n    $6nfFC$useSyncRef(context, ref);\n    // eslint-disable-next-line\n    let { ref: _ , ...otherProps } = context;\n    return otherProps;\n}\n/**\n * Provides DOM props to the nearest focusable child.\n */ function $e6afbd83fe6ebbd2$var$FocusableProvider(props, ref) {\n    let { children: children , ...otherProps } = props;\n    let context = {\n        ...otherProps,\n        ref: ref\n    };\n    return(/*#__PURE__*/ $6nfFC$react.createElement($e6afbd83fe6ebbd2$var$FocusableContext.Provider, {\n        value: context\n    }, children));\n}\nlet $e6afbd83fe6ebbd2$export$13f3202a3e5ddd5 = /*#__PURE__*/ $6nfFC$react.forwardRef($e6afbd83fe6ebbd2$var$FocusableProvider);\nfunction $e6afbd83fe6ebbd2$export$4c014de7c8940b4c(props, domRef) {\n    let { focusProps: focusProps  } = $6nfFC$useFocus(props);\n    let { keyboardProps: keyboardProps  } = $6nfFC$useKeyboard(props);\n    let interactions = $6nfFC$mergeProps(focusProps, keyboardProps);\n    let domProps = $e6afbd83fe6ebbd2$var$useFocusableContext(domRef);\n    let interactionProps = props.isDisabled ? {\n    } : domProps;\n    let autoFocusRef = $6nfFC$useRef(props.autoFocus);\n    $6nfFC$useEffect(()=>{\n        if (autoFocusRef.current && domRef.current) $6a99195332edec8b$export$80f3e147d781571c(domRef.current);\n        autoFocusRef.current = false;\n    }, [\n        domRef\n    ]);\n    return {\n        focusableProps: $6nfFC$mergeProps({\n            ...interactions,\n            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined\n        }, interactionProps)\n    };\n}\n\n\n\n\n\n\nexport {$9bf71ea28793e738$export$20e40289641fbbb6 as FocusScope, $9bf71ea28793e738$export$10c5169755ce7bd7 as useFocusManager, $9bf71ea28793e738$export$2d6ec8fc375ceafa as getFocusableTreeWalker, $9bf71ea28793e738$export$c5251b9e124bf29 as createFocusManager, $907718708eab68af$export$1a38b4ad7f578e1d as FocusRing, $e6afbd83fe6ebbd2$export$13f3202a3e5ddd5 as FocusableProvider, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c as useFocusable, $f7dceffc5ad7768b$export$4e328f61c538687f as useFocusRing, $6a99195332edec8b$export$80f3e147d781571c as focusSafely};\n//# sourceMappingURL=module.js.map\n","import {useControlledState as $4oA3P$useControlledState} from \"@react-stately/utils\";\n\n\nfunction $fc909762b330b746$export$61c6a8c84e605fb6(props) {\n    let [isOpen, setOpen] = $4oA3P$useControlledState(props.isOpen, props.defaultOpen || false, props.onOpenChange);\n    return {\n        isOpen: isOpen,\n        setOpen: setOpen,\n        open () {\n            setOpen(true);\n        },\n        close () {\n            setOpen(false);\n        },\n        toggle () {\n            setOpen(!isOpen);\n        }\n    };\n}\n\n\n\n\nexport {$fc909762b330b746$export$61c6a8c84e605fb6 as useOverlayTriggerState};\n//# sourceMappingURL=module.js.map\n"],"names":["useRef","useState","useCallback","useMemo","React.useEffect","React.createElement","Children","isValidElement","useContext","React.Fragment","cloneElement","$6nfFC$getInteractionModality","$6nfFC$runAfterTransition","$6nfFC$focusWithoutScrolling","$6nfFC$react","$6nfFC$useRef","$6nfFC$useContext","$6nfFC$useLayoutEffect","$6nfFC$useEffect","$6nfFC$isFocusVisible","$6nfFC$useState","$6nfFC$useCallback","$6nfFC$useFocusVisibleListener","$6nfFC$useFocus","$6nfFC$useFocusWithin","$6nfFC$useSyncRef","$6nfFC$useKeyboard","$6nfFC$mergeProps","$4oA3P$useControlledState"],"mappings":"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"}